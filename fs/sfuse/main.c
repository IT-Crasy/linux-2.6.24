/*
 * Copyright (c) 1997-2007 Erez Zadok <ezk@cs.stonybrook.edu>
 * Copyright (c) 2001-2007 Stony Brook University
 *
 * For specific licensing information, see the COPYING file distributed with
 * this package, or get one from
 * ftp://ftp.filesystems.org/pub/fistgen/COPYING.
 *
 * This Copyright notice must be kept intact and distributed with all
 * fistgen sources INCLUDING sources generated by fistgen.
 */
/*
 * File: fistgen/templates/Linux-2.6/main.c
 */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif /* HAVE_CONFIG_H */

#ifdef FISTGEN
# include "fist_sfuse.h"
#endif /* FISTGEN */

#include "fist.h"
#include "sfuse.h"
#include "fuse_i.h"

#include <linux/miscdevice.h>
#include <linux/pagemap.h>
#include <linux/slab.h>
#include <linux/file.h>
#include <linux/seq_file.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/parser.h>
#include <linux/statfs.h>
#include <linux/random.h>
#include <linux/sched.h>

#define FUSE_SUPER_MAGIC 0x65735546
#define FUSE_CTL_SUPER_MAGIC 0x65735543

struct list_head fuse_conn_list;
DEFINE_MUTEX(fuse_mutex);
static struct kmem_cache *fuse_req_cachep;
static struct super_block *fuse_control_sb;

struct fuse_mount_data {
	int fd;
	unsigned rootmode;
	unsigned user_id;
	unsigned group_id;
	unsigned fd_present : 1;
	unsigned rootmode_present : 1;
	unsigned user_id_present : 1;
	unsigned group_id_present : 1;
	unsigned flags;
	unsigned max_read;
	unsigned blksize;
};

enum {
    OPT_FD,
    OPT_ROOTMODE,
    OPT_USER_ID,
    OPT_GROUP_ID,
    OPT_DEFAULT_PERMISSIONS,
    OPT_ALLOW_OTHER,
    OPT_MAX_READ,
    OPT_BLKSIZE,
    OPT_FUSE,
    OPT_ERR
};

static match_table_t tokens = {
    {OPT_FD,			"fd=%u"},
    {OPT_ROOTMODE,		"rootmode=%o"},
    {OPT_USER_ID,		"user_id=%u"},
    {OPT_GROUP_ID,		"group_id=%u"},
    {OPT_DEFAULT_PERMISSIONS,	"default_permissions"},
    {OPT_ALLOW_OTHER,		"allow_other"},
    {OPT_MAX_READ,		"max_read=%u"},
    {OPT_BLKSIZE,		"blksize=%u"},
    {OPT_FUSE,                  "dir=%s"},
    {OPT_ERR,			NULL}
};

static struct kmem_cache *fuse_inode_cachep;

static void fuse_clear_inode(struct inode *inode)
{
    if (inode->i_sb->s_flags & MS_ACTIVE) {
	struct fuse_conn *fc = get_fuse_conn(inode);
	struct fuse_inode *fi = get_fuse_inode(inode);
	fuse_send_forget(fc, fi->forget_req, fi->nodeid, fi->nlookup);
	fi->forget_req = NULL;
    }
}

static int fuse_remount_fs(struct super_block *sb, int *flags, char *data)
{
    if (*flags & MS_MANDLOCK)
	return -EINVAL;

    return 0;
}

static void fuse_send_destroy(struct fuse_conn *fc)
{
    struct fuse_req *req = fc->destroy_req;
    if (req && fc->conn_init) {
	fc->destroy_req = NULL;
	req->in.h.opcode = FUSE_DESTROY;
	req->force = 1;
	request_send(fc, req);
	fuse_put_request(fc, req);
    }
}

static void fuse_put_super(struct super_block *sb)
{
    struct fuse_conn *fc = get_fuse_conn_super(sb);

    fuse_send_destroy(fc);
    spin_lock(&fc->lock);
    fc->connected = 0;
    fc->blocked = 0;
    spin_unlock(&fc->lock);
    /* Flush all readers on this fs */
    kill_fasync(&fc->fasync, SIGIO, POLL_IN);
    wake_up_all(&fc->waitq);
    wake_up_all(&fc->blocked_waitq);
    wake_up_all(&fc->reserved_req_waitq);
    mutex_lock(&fuse_mutex);
    list_del(&fc->entry);
    fuse_ctl_remove_conn(fc);
    mutex_unlock(&fuse_mutex);
    fuse_conn_put(fc);
}

static void fuse_umount_begin(struct vfsmount *vfsmnt, int flags)
{
    if (flags & MNT_FORCE)
	fuse_abort_conn(get_fuse_conn_super(vfsmnt->mnt_sb));
}

static struct inode *fuse_alloc_inode(struct super_block *sb)
{
    struct inode *inode;
    struct fuse_inode *fi;

    inode = kmem_cache_alloc(fuse_inode_cachep, GFP_KERNEL);
    if (!inode)
	return NULL;

    fi = get_fuse_inode(inode);
    fi->i_time = 0;
    fi->nodeid = 0;
    fi->nlookup = 0;
    fi->attr_version = 0;
    INIT_LIST_HEAD(&fi->write_files);
    fi->forget_req = fuse_request_alloc();
    if (!fi->forget_req) {
	kmem_cache_free(fuse_inode_cachep, inode);
	return NULL;
    }

    return inode;
}

static void fuse_destroy_inode(struct inode *inode)
{
    struct fuse_inode *fi = get_fuse_inode(inode);
    BUG_ON(!list_empty(&fi->write_files));
    if (fi->forget_req)
	fuse_request_free(fi->forget_req);
    kmem_cache_free(fuse_inode_cachep, inode);
}

static void fuse_read_inode(struct inode *inode)
{
    /* No op */
}

static void convert_fuse_statfs(struct kstatfs *stbuf, struct fuse_kstatfs *attr)
{
    stbuf->f_type    = FUSE_SUPER_MAGIC;
    stbuf->f_bsize   = attr->bsize;
    stbuf->f_frsize  = attr->frsize;
    stbuf->f_blocks  = attr->blocks;
    stbuf->f_bfree   = attr->bfree;
    stbuf->f_bavail  = attr->bavail;
    stbuf->f_files   = attr->files;
    stbuf->f_ffree   = attr->ffree;
    stbuf->f_namelen = attr->namelen;
    /* fsid is left zero */
}

static int fuse_statfs(struct dentry *dentry, struct kstatfs *buf)
{
    struct super_block *sb = dentry->d_sb;
    struct fuse_conn *fc = get_fuse_conn_super(sb);
    struct fuse_req *req;
    struct fuse_statfs_out outarg;
    int err;

    if (!fuse_allow_task(fc, current)) {
	buf->f_type = FUSE_SUPER_MAGIC;
	return 0;
    }

    req = fuse_get_req(fc);
    if (IS_ERR(req))
	return PTR_ERR(req);

    memset(&outarg, 0, sizeof(outarg));
    req->in.numargs = 0;
    req->in.h.opcode = FUSE_STATFS;
    req->in.h.nodeid = get_node_id(dentry->d_inode);
    req->out.numargs = 1;
    req->out.args[0].size =
	fc->minor < 4 ? FUSE_COMPAT_STATFS_SIZE : sizeof(outarg);
    req->out.args[0].value = &outarg;
    request_send(fc, req);
    err = req->out.h.error;
    if (!err)
	convert_fuse_statfs(buf, &outarg.st);
    fuse_put_request(fc, req);
    return err;
}

static int fuse_show_options(struct seq_file *m, struct vfsmount *mnt)
{
    struct fuse_conn *fc = get_fuse_conn_super(mnt->mnt_sb);

    seq_printf(m, ",user_id=%u", fc->user_id);
    seq_printf(m, ",group_id=%u", fc->group_id);
    if (fc->flags & FUSE_DEFAULT_PERMISSIONS)
	seq_puts(m, ",default_permissions");
    if (fc->flags & FUSE_ALLOW_OTHER)
	seq_puts(m, ",allow_other");
    if (fc->max_read != ~0)
	seq_printf(m, ",max_read=%u", fc->max_read);
    return 0;
}

static const struct super_operations fuse_super_operations = {
    .alloc_inode          = fuse_alloc_inode,
    .destroy_inode        = fuse_destroy_inode,
    .read_inode	          = fuse_read_inode,
    .clear_inode          = fuse_clear_inode,
    .drop_inode	          = generic_delete_inode,
    .remount_fs	          = fuse_remount_fs,
    .put_super	          = fuse_put_super,
    .umount_begin         = fuse_umount_begin,
    .statfs               = fuse_statfs,
    .show_options         = fuse_show_options,
};

/* sb we pass is sfuse's super_block */
int sfuse_interpose(struct dentry *lower_dentry, struct dentry *dentry, super_block_t *sb, int flag)
{
        inode_t *lower_inode;
        int err = 0;
	inode_t *inode;

	print_entry_location();

	lower_inode = lower_dentry->d_inode; /* CPW: moved after print_entry_location */

	BUG_ON(!lower_inode);
	BUG_ON(dentry->d_inode != NULL);

	/*
	 * We allocate our new inode below, by calling iget.
	 * iget will call our read_inode which will initialize some
	 * of the new inode's fields
	 */
	/* check that the lower file system didn't cross a mount point */
	if (lower_inode->i_sb != SUPERBLOCK_TO_LOWER(sb)) {
		err = -EXDEV;
		goto out;
	}
	inode = iget(sb, lower_inode->i_ino);

	if (!inode) {
		err = -EACCES;		/* should be impossible??? */
		goto out;
	}

	/*
	 * interpose the inode if not already interposed
	 * this is possible if the inode is being reused
	 * XXX: what happens if we get_empty_inode() but there's another already?
	 * for now, ASSERT() that this can't happen; fix later.
	 */
	if (INODE_TO_LOWER(inode) == NULL)
		INODE_TO_LOWER(inode) = igrab(lower_inode);

	/* Use different set of inode ops for symlinks & directories*/
	if (S_ISLNK(lower_inode->i_mode))
		inode->i_op = &sfuse_symlink_iops;
	else if (S_ISDIR(lower_inode->i_mode))
		inode->i_op = &sfuse_dir_iops;
	/* Use different set of file ops for directories */
	if (S_ISDIR(lower_inode->i_mode))
		inode->i_fop = &sfuse_dir_fops;

	/* properly initialize special inodes */
	if (S_ISBLK(lower_inode->i_mode) || S_ISCHR(lower_inode->i_mode) ||
            S_ISFIFO(lower_inode->i_mode) || S_ISSOCK(lower_inode->i_mode)) {
		init_special_inode(inode, lower_inode->i_mode, lower_inode->i_rdev);
	}

	/* Fix our inode's address operations to that of the lower inode */
	if (inode->i_mapping->a_ops != lower_inode->i_mapping->a_ops) {
		fist_dprint(7, "fixing inode 0x%x a_ops (0x%x -> 0x%x)\n",
                            (int) inode, (int) inode->i_mapping->a_ops,
                            (int) lower_inode->i_mapping->a_ops);
		inode->i_mapping->a_ops = lower_inode->i_mapping->a_ops;
	}

	/* only (our) lookup wants to do a d_add */
	if (flag)
		d_add(dentry, inode);
	else
		d_instantiate(dentry, inode);

	BUG_ON(!DENTRY_TO_PRIVATE(dentry));

	/* all well, copy inode attributes */
	fist_copy_attr_all(inode, lower_inode);

out:
	print_exit_status(err);
	return err;
}

/*
 * Parse mount options: dir=XXX and debug=N
 *
 * Returns the dentry object of the lower-level (lower) directory;
 * We want to mount our stackable file system on top of that lower directory.
 *
 * Sets default debugging level to N, if any.
 */
int sfuse_parse_options(super_block_t *sb, char *options, 
			struct dentry **lower_root, 
			struct vfsmount **lower_mount)
{
    struct nameidata nd;
    char *name, *tmp, *end;
    int err = 0;
    int dir_specified = 0;

    print_entry_location();

    /* We don't want to go off the end of our arguments later on. */
    for (end = options; *end; end++);

    while (options < end) {
	tmp = options;
	while (*tmp && *tmp != ',')
	    tmp++;
	*tmp = '\0';
	if (!strncmp("dir=", options, 4)) {
	    /* note: the name passed need not be encoded */
	    name = options + 4;
	    fist_dprint(4, "sfuse: using directory: %s\n", name);
	    err = path_lookup(name, LOOKUP_FOLLOW, &nd);
	    if (err) {
		printk("sfuse: error accessing lower directory '%s'\n", name);
		goto out;
	    }
	    *lower_root = nd.dentry;
	    *lower_mount = nd.mnt;
	    fist_dprint(6, "parse_options: new s_root, inode: %p, %p\n",
			*lower_root, (*lower_root)->d_inode);
	    dir_specified = 1;
	}
	else if (!strncmp("debug=", options, 6)) {
	    printk(KERN_WARNING "sfuse: Debugging support is not compiled in\n");
	} else {
	    printk(KERN_WARNING "sfuse: unrecognized option '%s'\n", options);
	}
	options = tmp + 1;
    }
    if (dir_specified != 1) {
	err = -EINVAL; /* dir option must be specified */
	printk("Please specify dir option\n");
    }

  out:
    print_exit_location();
    return err;
}

static int parse_fuse_opt(char *opt, struct fuse_mount_data *d, int is_bdev, 
			  char *retdata)
{
    char *p;
    memset(d, 0, sizeof(struct fuse_mount_data));
    d->max_read = ~0;
    d->blksize = 512;

    while ((p = strsep(&opt, ",")) != NULL) {
	int token;
	int value;
	substring_t args[MAX_OPT_ARGS];
	if (!*p)
	    continue;

	token = match_token(p, tokens, args);
	switch (token) {
	    case OPT_FD:
		if (match_int(&args[0], &value))
		    return 0;
		d->fd = value;
		d->fd_present = 1;
		break;

	    case OPT_ROOTMODE:
		if (match_octal(&args[0], &value))
		    return 0;
		if (!fuse_valid_type(value))
		    return 0;
		d->rootmode = value;
		d->rootmode_present = 1;
		break;

	    case OPT_USER_ID:
		if (match_int(&args[0], &value))
		    return 0;
		d->user_id = value;
		d->user_id_present = 1;
		break;

	    case OPT_GROUP_ID:
		if (match_int(&args[0], &value))
		    return 0;
		d->group_id = value;
		d->group_id_present = 1;
		break;

	    case OPT_DEFAULT_PERMISSIONS:
		d->flags |= FUSE_DEFAULT_PERMISSIONS;
		break;

	    case OPT_ALLOW_OTHER:
		d->flags |= FUSE_ALLOW_OTHER;
		break;

	    case OPT_MAX_READ:
		if (match_int(&args[0], &value))
		    return 0;
		d->max_read = value;
		break;

	    case OPT_BLKSIZE:
		if (!is_bdev || match_int(&args[0], &value))
		    return 0;
		d->blksize = value;
		break;

	    case OPT_FUSE:
		if(retdata)
		    strcpy(retdata, p);
		goto out;

	    default:
		return 0;
	}
    }

  out:
    if (!d->fd_present || !d->rootmode_present ||
	!d->user_id_present || !d->group_id_present)
	return 0;

    return 1;
}

static struct fuse_conn *new_conn(void)
{
    struct fuse_conn *fc;
    int err;

    fc = kzalloc(sizeof(*fc), GFP_KERNEL);
    if (fc) {
	fc->magic = 54321;
	spin_lock_init(&fc->lock);
	mutex_init(&fc->inst_mutex);
	atomic_set(&fc->count, 1);
	init_waitqueue_head(&fc->waitq);
	init_waitqueue_head(&fc->blocked_waitq);
	init_waitqueue_head(&fc->reserved_req_waitq);
	INIT_LIST_HEAD(&fc->pending);
	INIT_LIST_HEAD(&fc->processing);
	INIT_LIST_HEAD(&fc->io);
	INIT_LIST_HEAD(&fc->interrupts);
	atomic_set(&fc->num_waiting, 0);
	fc->bdi.ra_pages = (VM_MAX_READAHEAD * 1024) / PAGE_CACHE_SIZE;
	fc->bdi.unplug_io_fn = default_unplug_io_fn;
	err = bdi_init(&fc->bdi);
	if (err) {
	    kfree(fc);
	    fc = NULL;
	    goto out;
	}
	fc->reqctr = 0;
	fc->blocked = 1;
	fc->attr_version = 1;
	get_random_bytes(&fc->scramble_key, sizeof(fc->scramble_key));
    }
  out:
    return fc;
}

static struct inode *get_root_inode(struct super_block *sb, unsigned mode)
{
    struct fuse_attr attr;
    memset(&attr, 0, sizeof(attr));

    attr.mode = mode;
    attr.ino = FUSE_ROOT_ID;
    attr.nlink = 1;
    return fuse_iget(sb, 1, 0, &attr, 0, 0);
}

static u64 conn_id(void)
{
    static u64 ctr = 1;
    return ctr++;
}

static void process_init_reply(struct fuse_conn *fc, struct fuse_req *req)
{
    struct fuse_init_out *arg = &req->misc.init_out;

    if (req->out.h.error || arg->major != FUSE_KERNEL_VERSION)
	fc->conn_error = 1;
    else {
	unsigned long ra_pages;

	if (arg->minor >= 6) {
	    ra_pages = arg->max_readahead / PAGE_CACHE_SIZE;
	    if (arg->flags & FUSE_ASYNC_READ)
		fc->async_read = 1;
	    if (!(arg->flags & FUSE_POSIX_LOCKS))
		fc->no_lock = 1;
	    if (arg->flags & FUSE_ATOMIC_O_TRUNC)
		fc->atomic_o_trunc = 1;
	} else {
	    ra_pages = fc->max_read / PAGE_CACHE_SIZE;
	    fc->no_lock = 1;
	}

	fc->bdi.ra_pages = min(fc->bdi.ra_pages, ra_pages);
	fc->minor = arg->minor;
	fc->max_write = arg->minor < 5 ? 4096 : arg->max_write;
	fc->conn_init = 1;
    }
    fuse_put_request(fc, req);
    fc->blocked = 0;
    wake_up_all(&fc->blocked_waitq);
}

static void fuse_send_init(struct fuse_conn *fc, struct fuse_req *req)
{
    struct fuse_init_in *arg = &req->misc.init_in;

    arg->major = FUSE_KERNEL_VERSION;
    arg->minor = FUSE_KERNEL_MINOR_VERSION;
    arg->max_readahead = fc->bdi.ra_pages * PAGE_CACHE_SIZE;
    arg->flags |= FUSE_ASYNC_READ | FUSE_POSIX_LOCKS | FUSE_ATOMIC_O_TRUNC;
    req->in.h.opcode = FUSE_INIT;
    req->in.numargs = 1;
    req->in.args[0].size = sizeof(*arg);
    req->in.args[0].value = arg;
    req->out.numargs = 1;
    /* Variable length arguement used for backward compatibility
       with interface version < 7.5.  Rest of init_out is zeroed
       by do_get_request(), so a short reply is not a problem */
    req->out.argvar = 1;
    req->out.args[0].size = sizeof(struct fuse_init_out);
    req->out.args[0].value = &req->misc.init_out;
    req->end = process_init_reply;
    request_send_background(fc, req);
}

/* for attach mode, we use a different ->read_super() in attach.c */
static int sfuse_read_super(super_block_t *sb, void *raw_data, int silent)
{
    struct dentry *lower_root = NULL;
    struct vfsmount *lower_mount = NULL;
    struct sfuse_sb_info *sbi = NULL;
    int err = 0;
    struct fuse_mount_data d;
    struct file *file;
    struct inode *root;
    struct inode *inode = NULL, *lower_inode = NULL;
    struct dentry *root_dentry = NULL;
    struct fuse_req *init_req;
    char retdata[20];
    int is_bdev = sb->s_bdev != NULL;

    /* Testing */
    struct inode *inode_temp = NULL;

    print_entry_location();

    if (!raw_data) {
	printk(KERN_WARNING "sfuse_read_super: missing data argument\n");
	err = -EINVAL;
	goto out_no_raw;
    }

    /* FUSE part */
    if(!parse_fuse_opt((char *)raw_data, &d, is_bdev, (char *)&retdata))
	return -EINVAL;

    if(!raw_data)
	raw_data = kmalloc(strlen(retdata), GFP_KERNEL);


    strcpy(raw_data, retdata);

    if(is_bdev)
    {
#ifdef CONFIG_BLOCK
	if(!sb_set_blocksize(sb, d.blksize))
	    return -EINVAL;
#endif
    }
    else
    {
	sb->s_blocksize = PAGE_CACHE_SIZE;
	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
    }

    sb->s_magic = FUSE_SUPER_MAGIC;

    /* FUSE create connection */
    file = fget(d.fd);
    if(!file)
	return -EINVAL;

    if(file->f_op != &fuse_dev_operations)
	return -EINVAL;

    /*
     * Allocate superblock private data
     */
    sbi = kmalloc(sizeof(struct sfuse_sb_info), GFP_KERNEL);
    sbi->magic = 12345;
    sbi->fc = new_conn();
    if(!sbi->fc)
	return -ENOMEM;

    sbi->fc->flags = d.flags;
    sbi->fc->user_id = d.user_id;
    sbi->fc->group_id = d.group_id;
    sbi->fc->max_read = d.max_read;

    sb->s_fs_info = sbi;

    /* Still doing FUSE stuff */
    err = -ENOMEM;
    root = get_root_inode(sb, d.rootmode);
    if (!root)
	goto on_error;

    /* Change the dir operations to SFUSE otherwise FUSE functions will be 
     * called.
     */
    root->i_fop = &sfuse_dir_fops;

/*     root_dentry = d_alloc_root(root); */
/*     if (!root_dentry) { */
/* 	iput(root); */
/* 	goto on_error; */
/*     } */

    init_req = fuse_request_alloc();
    if (!init_req)
	goto on_error;

    if (is_bdev) {
	sbi->fc->destroy_req = fuse_request_alloc();
	if (!sbi->fc->destroy_req)
	    goto on_error;
    }

    mutex_lock(&fuse_mutex);
    err = -EINVAL;
    if (file->private_data)
	goto on_error;

    sbi->fc->id = conn_id();
    err = fuse_ctl_add_conn(sbi->fc);
    if (err)
	goto on_error;

    list_add_tail(&sbi->fc->entry, &fuse_conn_list);
    sb->s_root = root_dentry;
    sbi->fc->connected = 1;
    file->private_data = fuse_conn_get(sbi->fc);
    mutex_unlock(&fuse_mutex);
    /*
     * atomic_dec_and_test() in fput() provides the necessary
     * memory barrier for file->private_data to be visible on all
     * CPUs after this
     */
    fput(file);

    fuse_send_init(sbi->fc, init_req);

    /* End FUSE */

    if ((err = sfuse_parse_options(sb, raw_data, &lower_root, 
				   &lower_mount))) 
    {
	goto out_free;
    }

    if (IS_ERR(lower_root)) {
	printk(KERN_WARNING "sfuse_read_super: lookup_dentry "
	       "failed (err = %ld)\n", PTR_ERR(lower_root));
	err = PTR_ERR(lower_root);
	goto out_free;
    }

    if (!lower_root->d_inode) {
	printk(KERN_WARNING "sfuse_read_super: no directory "
	       "to interpose on\n");
	goto out_dput;
    }

    SUPERBLOCK_TO_LOWER(sb) = lower_root->d_sb;

    sb->s_maxbytes = lower_root->d_sb->s_maxbytes + MAX_LFS_FILESIZE;

    sb->s_op = &sfuse_sops;

    /*
     * we can't use d_alloc_root if we want to use
     * our own interpose function unchanged,
     * so we simply replicate *most* of the code in d_alloc_root here
     */

    sb->s_root = d_alloc(NULL, &(const struct qstr){hash: 0, 
		name: "/", len: 1});
    if (IS_ERR(sb->s_root)) {
	printk(KERN_WARNING "sfuse_read_super: d_alloc failed\n");
	err = -ENOMEM;
	goto out_dput;
    }

    sb->s_root->d_op = &sfuse_dops;
    sb->s_root->d_sb = sb;
    sb->s_root->d_parent = sb->s_root;

    /* link the upper and lower dentries */
    DENTRY_TO_PRIVATE_SM(sb->s_root) = (struct sfuse_dentry_info *) 
	KMALLOC(sizeof(struct sfuse_dentry_info), GFP_KERNEL);

    if (!DENTRY_TO_PRIVATE(sb->s_root)) {
	err = -ENOMEM;
	goto out_dput2;
    }
    DENTRY_TO_LOWER(sb->s_root) = lower_root;
    DENTRY_TO_LVFSMNT(sb->s_root) = lower_mount;

    lower_inode = lower_root->d_inode;
    inode = iget(sb, lower_inode->i_ino);
    if(INODE_TO_LOWER(inode) == NULL)
	INODE_TO_LOWER(inode) = igrab(lower_inode);

    inode_temp = INODE_TO_LOWER(inode);

    if ((err = sfuse_interpose(lower_root, sb->s_root, sb, 0)) != 0)
	goto out_dput2;

    fist_print_dentry("sfuse_read_super OUT lower_dentry", lower_root);
    fist_print_inode("sfuse_read_super OUT lower_inode", lower_root->d_inode);
    // next line causes null ptr deref at mount(2) time
    // fist_print_dentry("%s OUT sb->s_root", __FUNCTION__, sb->s_root);
    goto out;

  out_dput2:
    dput(sb->s_root);
  out_dput:
    dput(lower_root);
  out_free:
    mntput(lower_mount);
    KFREE(SUPERBLOCK_TO_PRIVATE(sb));
    SUPERBLOCK_TO_PRIVATE_SM(sb) = NULL;
  out:
    fist_print_sb("OUT sb", sb);
    if (SUPERBLOCK_TO_PRIVATE(sb))
	fist_print_sb("OUT lower_sb", SUPERBLOCK_TO_LOWER(sb));
  out_no_raw:
  on_error:
    print_exit_location();
    return err;
}

static int sfuse_get_sb(struct file_system_type *fs_type,
			int flags, const char *dev_name,
			void *raw_data, struct vfsmount *mnt)
{

    return get_sb_nodev(fs_type, flags, raw_data, sfuse_read_super, mnt);
}

void sfuse_kill_block_super(struct super_block *sb)
{
	generic_shutdown_super(sb);
/*
 *	XXX: BUG: Halcrow: Things get unstable sometime after this point:
 *
 *	lib/rwsem-spinlock.c:127: spin_is_locked on uninitialized
 *	spinlock a1c953d8.
 *
 *	fs/fs-writeback.c:402: spin_lock(fs/super.c:a0381828) already
 *	locked by fs/fs-writeback.c/402
 *
 *	Apparently, someone's not releasing a lock on sb_lock...
*/
}




void fuse_conn_put(struct fuse_conn *fc)
{
    if (atomic_dec_and_test(&fc->count)) {
	if (fc->destroy_req)
	    fuse_request_free(fc->destroy_req);
	mutex_destroy(&fc->inst_mutex);
	bdi_destroy(&fc->bdi);
	kfree(fc);
    }
}

struct fuse_conn *fuse_conn_get(struct fuse_conn *fc)
{
    atomic_inc(&fc->count);
    return fc;
}



static struct dentry *fuse_ctl_add_dentry(struct dentry *parent,
					  struct fuse_conn *fc,
					  const char *name,
					  int mode, int nlink,
					  const struct inode_operations *iop,
					  const struct file_operations *fop)
{
    struct dentry *dentry;
    struct inode *inode;

    BUG_ON(fc->ctl_ndents >= FUSE_CTL_NUM_DENTRIES);
    dentry = d_alloc_name(parent, name);
    if (!dentry)
	return NULL;

    fc->ctl_dentry[fc->ctl_ndents++] = dentry;
    inode = new_inode(fuse_control_sb);
    if (!inode)
	return NULL;

    inode->i_mode = mode;
    inode->i_uid = fc->user_id;
    inode->i_gid = fc->group_id;
    inode->i_atime = inode->i_mtime = inode->i_ctime = CURRENT_TIME;
    /* setting ->i_op to NULL is not allowed */
    if (iop)
	inode->i_op = iop;
    inode->i_fop = fop;
    inode->i_nlink = nlink;
    inode->i_private = fc;
    d_add(dentry, inode);
    return dentry;
}

static struct fuse_conn *fuse_ctl_file_conn_get(struct file *file)
{
    struct fuse_conn *fc;
    mutex_lock(&fuse_mutex);
    fc = file->f_path.dentry->d_inode->i_private;
    if (fc)
	fc = fuse_conn_get(fc);
    mutex_unlock(&fuse_mutex);
    return fc;
}

static ssize_t fuse_conn_abort_write(struct file *file, const char __user *buf,
				     size_t count, loff_t *ppos)
{
    struct fuse_conn *fc = fuse_ctl_file_conn_get(file);
    if (fc) {
	fuse_abort_conn(fc);
	fuse_conn_put(fc);
    }
    return count;
}

static ssize_t fuse_conn_waiting_read(struct file *file, char __user *buf,
				      size_t len, loff_t *ppos)
{
    char tmp[32];
    size_t size;

    if (!*ppos) {
	struct fuse_conn *fc = fuse_ctl_file_conn_get(file);
	if (!fc)
	    return 0;

	file->private_data=(void *)(long)atomic_read(&fc->num_waiting);
	fuse_conn_put(fc);
    }
    size = sprintf(tmp, "%ld\n", (long)file->private_data);
    return simple_read_from_buffer(buf, len, ppos, tmp, size);
}

static const struct file_operations fuse_ctl_abort_ops = {
    .open = nonseekable_open,
    .write = fuse_conn_abort_write,
};

static const struct file_operations fuse_ctl_waiting_ops = {
    .open = nonseekable_open,
    .read = fuse_conn_waiting_read,
};

/*
 * Remove a connection from the control filesystem (if it exists).
 * Caller must hold fuse_mutex
 */
void fuse_ctl_remove_conn(struct fuse_conn *fc)
{
    int i;

    if (!fuse_control_sb)
	return;

    for (i = fc->ctl_ndents - 1; i >= 0; i--) {
	struct dentry *dentry = fc->ctl_dentry[i];
	dentry->d_inode->i_private = NULL;
	d_drop(dentry);
	dput(dentry);
    }
    fuse_control_sb->s_root->d_inode->i_nlink--;
}

/*
 * Add a connection to the control filesystem (if it exists).  Caller
 * must hold fuse_mutex
 */
int fuse_ctl_add_conn(struct fuse_conn *fc)
{
    struct dentry *parent;
    char name[32];

    if (!fuse_control_sb)
	return 0;

    parent = fuse_control_sb->s_root;
    inc_nlink(parent->d_inode);
    sprintf(name, "%llu", (unsigned long long) fc->id);
    parent = fuse_ctl_add_dentry(parent, fc, name, S_IFDIR | 0500, 2,
				 &simple_dir_inode_operations,
				 &simple_dir_operations);
    if (!parent)
	goto err;

    if (!fuse_ctl_add_dentry(parent, fc, "waiting", S_IFREG | 0400, 1,
			     NULL, &fuse_ctl_waiting_ops) ||
	!fuse_ctl_add_dentry(parent, fc, "abort", S_IFREG | 0200, 1,
			     NULL, &fuse_ctl_abort_ops))
	goto err;

    return 0;

  err:
    fuse_ctl_remove_conn(fc);
    return -ENOMEM;
}

static int fuse_fill_super(struct super_block *sb, void *data, int silent)
{
    struct fuse_conn *fc;
    struct inode *root;
    struct fuse_mount_data d;
    struct file *file;
    struct dentry *root_dentry;
    struct fuse_req *init_req;
    int err;
    int is_bdev = sb->s_bdev != NULL;

    if (sb->s_flags & MS_MANDLOCK)
	return -EINVAL;

    if (!parse_fuse_opt((char *) data, &d, is_bdev, NULL))
	return -EINVAL;

    if (is_bdev) {
#ifdef CONFIG_BLOCK
	if (!sb_set_blocksize(sb, d.blksize))
	    return -EINVAL;
#endif
    } else {
	sb->s_blocksize = PAGE_CACHE_SIZE;
	sb->s_blocksize_bits = PAGE_CACHE_SHIFT;
    }
    sb->s_magic = FUSE_SUPER_MAGIC;
    sb->s_op = &fuse_super_operations;
    sb->s_maxbytes = MAX_LFS_FILESIZE;

    file = fget(d.fd);
    if (!file)
	return -EINVAL;

    if (file->f_op != &fuse_dev_operations)
	return -EINVAL;

    fc = new_conn();
    if (!fc)
	return -ENOMEM;

    fc->flags = d.flags;
    fc->user_id = d.user_id;
    fc->group_id = d.group_id;
    fc->max_read = d.max_read;

    /* Used by get_root_inode() */
    sb->s_fs_info = fc;

    err = -ENOMEM;
    root = get_root_inode(sb, d.rootmode);
    if (!root)
	goto err;

    root_dentry = d_alloc_root(root);
    if (!root_dentry) {
	iput(root);
	goto err;
    }

    init_req = fuse_request_alloc();
    if (!init_req)
	goto err_put_root;

    if (is_bdev) {
	fc->destroy_req = fuse_request_alloc();
	if (!fc->destroy_req)
	    goto err_put_root;
    }

    mutex_lock(&fuse_mutex);
    err = -EINVAL;
    if (file->private_data)
	goto err_unlock;

    fc->id = conn_id();
    err = fuse_ctl_add_conn(fc);
    if (err)
	goto err_unlock;

    list_add_tail(&fc->entry, &fuse_conn_list);
    sb->s_root = root_dentry;
    fc->connected = 1;
    file->private_data = fuse_conn_get(fc);
    mutex_unlock(&fuse_mutex);
    /*
     * atomic_dec_and_test() in fput() provides the necessary
     * memory barrier for file->private_data to be visible on all
     * CPUs after this
     */
    fput(file);

    fuse_send_init(fc, init_req);

    return 0;

  err_unlock:
    mutex_unlock(&fuse_mutex);
    fuse_request_free(init_req);
  err_put_root:
    dput(root_dentry);
  err:
    fput(file);
    fuse_conn_put(fc);
    return err;
}

static int fuse_get_sb(struct file_system_type *fs_type,
		       int flags, const char *dev_name,
		       void *raw_data, struct vfsmount *mnt)
{
    return get_sb_nodev(fs_type, flags, raw_data, fuse_fill_super, mnt);
}

static struct file_system_type sfuse_fs_type = {
	.owner          = THIS_MODULE,
	.name           = "sfuse",
	.get_sb         = sfuse_get_sb,
	.kill_sb        = sfuse_kill_block_super,
	.fs_flags       = 0,
};

static struct file_system_type fuse_fs_type = {
    .owner		= THIS_MODULE,
    .name		= "fuse",
    .fs_flags	        = FS_HAS_SUBTYPE,
    .get_sb		= fuse_get_sb,
    .kill_sb	        = kill_anon_super,
};

static int fuse_get_sb_blk(struct file_system_type *fs_type,
			   int flags, const char *dev_name,
			   void *raw_data, struct vfsmount *mnt)
{
    return get_sb_bdev(fs_type, flags, dev_name, raw_data, fuse_fill_super,
		       mnt);
}

static struct file_system_type fuseblk_fs_type = {
    .owner		= THIS_MODULE,
    .name		= "fuseblk",
    .get_sb		= fuse_get_sb_blk,
    .kill_sb	= kill_block_super,
    .fs_flags	= FS_REQUIRES_DEV | FS_HAS_SUBTYPE,
};

static inline int register_fuseblk(void)
{
    return register_filesystem(&fuseblk_fs_type);
}

static inline void unregister_fuseblk(void)
{
    unregister_filesystem(&fuseblk_fs_type);
}

/* file system initialize functions */
static void fuse_inode_init_once(struct kmem_cache *cachep, void *foo)
{
    struct inode * inode = foo;

    inode_init_once(inode);
}

static int __init fuse_fs_init(void)
{
    int err;

//    err = register_filesystem(&fuse_fs_type);
//    if (err)
//	goto out;

    err = register_fuseblk();
    if (err)
	goto out_unreg;

    fuse_inode_cachep = kmem_cache_create("fuse_inode",
					  sizeof(struct fuse_inode),
					  0, SLAB_HWCACHE_ALIGN,
					  fuse_inode_init_once);
    err = -ENOMEM;
    if (!fuse_inode_cachep)
	goto out_unreg2;

    return 0;

  out_unreg2:
    unregister_fuseblk();
  out_unreg:
//    unregister_filesystem(&fuse_fs_type);
  out:
    return err;
}

static struct miscdevice fuse_miscdevice = {
    .minor = FUSE_MINOR,
    .name  = "fuse",
    .fops = &fuse_dev_operations,
};

static decl_subsys(sfuse, NULL, NULL);
static decl_subsys(connections, NULL, NULL);

static int fuse_sysfs_init(void)
{
    int err;

    kobj_set_kset_s(&sfuse_subsys, fs_subsys);
    err = subsystem_register(&sfuse_subsys);
    if (err)
	goto out_err;

    kobj_set_kset_s(&connections_subsys, sfuse_subsys);
    err = subsystem_register(&connections_subsys);
    if (err)
	goto out_fuse_unregister;

    return 0;

  out_fuse_unregister:
    subsystem_unregister(&sfuse_subsys);
  out_err:
    return err;
}

static int fuse_ctl_fill_super(struct super_block *sb, void *data, int silent)
{
    struct tree_descr empty_descr = {""};
    struct fuse_conn *fc;
    int err;

    err = simple_fill_super(sb, FUSE_CTL_SUPER_MAGIC, &empty_descr);
    if (err)
	return err;

    mutex_lock(&fuse_mutex);
    BUG_ON(fuse_control_sb);
    fuse_control_sb = sb;
    list_for_each_entry(fc, &fuse_conn_list, entry) {
	err = fuse_ctl_add_conn(fc);
	if (err) {
	    fuse_control_sb = NULL;
	    mutex_unlock(&fuse_mutex);
	    return err;
	}
    }
    mutex_unlock(&fuse_mutex);

    return 0;
}

static int fuse_ctl_get_sb(struct file_system_type *fs_type, int flags,
			   const char *dev_name, void *raw_data,
			   struct vfsmount *mnt)
{
    return get_sb_single(fs_type, flags, raw_data,
			 fuse_ctl_fill_super, mnt);
}

static void fuse_ctl_kill_sb(struct super_block *sb)
{
    struct fuse_conn *fc;

    mutex_lock(&fuse_mutex);
    fuse_control_sb = NULL;
    list_for_each_entry(fc, &fuse_conn_list, entry)
	fc->ctl_ndents = 0;
    mutex_unlock(&fuse_mutex);

    kill_litter_super(sb);
}

static struct file_system_type fuse_ctl_fs_type = {
    .owner		= THIS_MODULE,
    .name		= "fusectl",
    .get_sb		= fuse_ctl_get_sb,
    .kill_sb	= fuse_ctl_kill_sb,
};

int __init fuse_ctl_init(void)
{
    return register_filesystem(&fuse_ctl_fs_type);
}

void fuse_ctl_cleanup(void)
{
    unregister_filesystem(&fuse_ctl_fs_type);
}


/* Initialize sfuse file system */
static int __init init_sfuse_fs(void)
{
    int err;
    printk("Registering sfuse\n");

    /* FiST section */
    err = sfuse_init_inodecache();
    if (err)
	goto out1;
    err = register_filesystem(&sfuse_fs_type);
    if (err)
	goto out;

    /* FUSE section */
    INIT_LIST_HEAD(&fuse_conn_list);
    err = fuse_fs_init();
    if(err)
	goto out;

    err = fuse_dev_init();
    if(err)
	goto out;

    err = fuse_sysfs_init();
    if(err)
	goto out;

    err = fuse_ctl_init();
    if(err)
	goto out;

    return 0;
  out:
    sfuse_destroy_inodecache();
  out1:
    return err;
}

static void __exit exit_sfuse_fs(void)
{
    printk("Unregistering sfuse\n");
    sfuse_destroy_inodecache();
    unregister_filesystem(&sfuse_fs_type);
}

MODULE_AUTHOR("Sumit Narayan <sumit.narayan@uconn.edu>");
MODULE_DESCRIPTION("Stackable FUSE file system");

/* This definition must only appear after we include <linux/module.h> */
MODULE_LICENSE("GPL");	/* defined via "license" decl in .fist file */
#ifndef MODULE_LICENSE
# error must define module license via fistgen license declaration
#endif /* not MODULE_LICENSE */

module_param(fist_debug_var, int, 0644);
MODULE_PARM_DESC(fist_debug_var, "Debug level");

module_init(init_sfuse_fs)
module_exit(exit_sfuse_fs)

/*
 * Local variables:
 * c-basic-offset: 4
 * End:
 */
